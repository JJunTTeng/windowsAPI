#include "yaCollisionManager.h"
#include "yaScene.h"
#include "yaSceneManager.h"
#include "yaGameObject.h"
#include "yaCollider.h"
namespace ya
{
	WORD CollisionManager::mMatrix[_COLLIDER_LAYER] = {};
	void CollisionManager::Tick()
	{
		Scene* playScene = SceneManager::GetPlayScene();

		for (size_t row = 0; row < _COLLIDER_LAYER; row++)
		{
			for (size_t col = 0; col < _COLLIDER_LAYER; col++)
			{
				if (mMatrix[row] & (1 << col)) 
				{
					//충돌 이 되었는지 안되었는지를 검사해줘야 함.
					LayerCollision(playScene, (eColliderLayer)row, (eColliderLayer)col);
				}
			}
		}
	}
	void CollisionManager::SetLayar(eColliderLayer left, eColliderLayer right , bool value)
	{
		//더 작은 숫자를 행으로 더 큰숫자를 열로
		UINT row = 0;	//행
		UINT col = 0;	//열

		UINT iLeft = (UINT)left;
		UINT iRight = (UINT)right;

		if (iLeft < iRight)
		{
			row = (UINT)left;
			col = (UINT)right;
		}
		else
		{
			row = (UINT)right;
			col = (UINT)left;
		}

		if (value == true)
			mMatrix[row] |= (1 << col);
		else
			mMatrix[row] &= ~(1 << col);

		
	}
	void CollisionManager::LayerCollision(Scene* scene, eColliderLayer left, eColliderLayer right)
	{
		//모든 left 오브젝트들과 right 오브젝트들을 가져와서 비교해줘야 한다.
		std::vector<GameObject*>& lefts = scene->GetGameObjects(left);
		std::vector<GameObject*>& rights = scene->GetGameObjects(right);

		//auto를 쓰는 이유 iterator 이 너무 기니까 
		for (auto leftObject : lefts)
		{
			if (leftObject->GetComponent<Collider>() == nullptr)
				continue;

			for (auto rightObject : rights)
			{
				if (rightObject->GetComponent<Collider>() == nullptr)
					continue;

				if (leftObject == rightObject)
					continue;

				if (Intersect(leftObject->GetComponent<Collider>(), rightObject->GetComponent<Collider>()))
				{
					//충돌
					int a = 0;
				}
				else
				{
					//충돌 x
				}
			}
		}
	}
	bool CollisionManager::Intersect(Collider* left, Collider* right)
	{
		Vector2 leftPos = left->GetPos();
		Vector2 rightPos = right->GetPos();

		Vector2 leftScale = left->GetScale();
		Vector2 rightScale = right->GetScale();

		if (fabs(left->GetPos().x - right->GetPos().x) < (left->GetScale().x / 2.0f + right->GetScale().x / 2.0f) &&
			fabs(left->GetPos().y - right->GetPos().y) < (left->GetScale().y / 2.0f + right->GetScale().y / 2.0f))
		{
			return true;
		}

		return false;
	}
}